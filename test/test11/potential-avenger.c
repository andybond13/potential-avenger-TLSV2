//potential-avenger.c
//Andrew Stershic
//DCML, Duke University
//(c) 2013, 2014

#include <potential-avenger.h>
#include <omp.h>
#include <limits>
#include <sys/stat.h>

using namespace std;

PotentialAvenger::PotentialAvenger(double& in0, double& in1, double& in2, unsigned& in3, double& in4, unsigned& in6, int& in7, double& in8, double& in9, unsigned& in10, unsigned& in11, unsigned& in12, string& in13, unsigned& in14, unsigned& in15, unsigned& in16, string& path){
    strain_rate = in0;
    ts_refine = in1;
    end_t = in2;
    Nelt = in3;
    lc = in4;
    printVTK = in6;
    oneAtATime = in7;
    minOpenDist = in8;
	alpha = in9;
    TLSoption = in10;
    visualizeCracks = in11;
    fullCompression = in12;
	sm = in13;
	elemDeath = in14;
	frontExtension = in15;
	maxIteration = in16;
    _path = "./results";

    _numFrag = 0;    

    //make plot files
    printClean();
	plotEnergies();
	plotForceDisp();
    plotFrags();
    plotHisto();
    plotSTheta();
    plotResidual();

};

PotentialAvenger::~PotentialAvenger(){
// create a plot file if necessary
    std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
    FILE * pFileP;
    pFileP = fopen( plotFil.c_str(), "w" );
    fprintf( pFileP, "#!/bin/bash\n" );
    fprintf( pFileP, "# shell script generated by <ring.h>" );
    fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
    if ( _EnrgFile.size() != 0 ) {
        std::string enrgFil = "./gnuplot/plotEnrg.plt";
        fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
    }
    if ( _FDFile.size() != 0 ) {
        std::string FDFil = "./gnuplot/plotFD.plt";
        fprintf( pFileP, "gnuplot %s\n", FDFil.c_str() );
    }
    if ( _FragFile.size() != 0 ) {
        std::string fragFil = "./gnuplot/plotFragInfo.plt";
        fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
    }
    if ( _HistoFile.size() != 0 ) {
        std::string histoFil = "./gnuplot/plotHisto.plt";
        fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
    }
    if ( _SThetaFile.size() != 0 ) {
        std::string sThetaFil = "./gnuplot/plotSTheta.plt";
        fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
    }
    if ( _ResidualFile.size() != 0 ) {
        std::string residualFil = "./gnuplot/plotResidual.plt";
        fprintf( pFileP, "gnuplot %s\n", residualFil.c_str() );
    }
    if ( _ResidualFile2.size() != 0 ) {
        std::string residualFil2 = "./gnuplot/plotResidual2.plt";
        fprintf( pFileP, "gnuplot %s\n", residualFil2.c_str() );
    }
    fprintf( pFileP, "\n/usr/bin/open -a \"/Applications/Google Chrome.app\" ./pngFiles/*.svg &\n" );
    fclose( pFileP );
    chmod( plotFil.c_str(), 0775 );

};

template <typename T> T min(const vector<T>& in) {
    assert(in.size() > 0);
    T min = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] < min) min = in[i];
    }
    return min;
}

template <typename T> T min(const T& a, const T& b, const T& c, const T& d) {
	return min( min(a,b), min(c,d) );
}

template <typename T> T max(const vector<T>& in) {
    assert(in.size() > 0);
    T max = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] > max) max = in[i];
    }
    return max;
}

template <typename T> T max(const T& a, const T& b, const T& c, const T& d) {
	return max( max(a,b), max(c,d) );	
}

double dotProduct(const vector<double> a, const vector<double> b) {
    double sum = 0;
    assert(a.size() == b.size() );
    for (unsigned i = 0; i < a.size(); ++i) sum+= a[i]*b[i];
    return sum;
}

int median(const vector<int> in) {
    return in[(in.size()-1)/2];
}

double sum(const vector<double> in) {
    return dotProduct(in,vector<double>(in.size(),1));
}

unsigned PotentialAvenger::sumU(const vector<unsigned> in) {
    unsigned result = 0;
    for (unsigned i = 0; i < in.size(); ++i) result += in[i];
    return result;
}

template <typename T> double sgn(T val) {
    return (T(0) < val) - (val < T(0));
}

double printable (double in) {
    double limit = numeric_limits<double>::epsilon();
	assert(isnan(in) == 0);
	assert(isinf(in) == 0);
	if (fabs(in) < limit) return 0.0;
    else return in;
}

void PotentialAvenger::run(const double& Ein, const double& rhoIn, const double& Ain, const double& Lin, const double& Ycin, const vector<double>& pg, const vector<double>& wg, const vector<double>& phiIn, const vector<Segment*> segIn, const unsigned& nucleatedIn, bool& vbc, const vector<double>& eIn, const vector<double>& xIn, vector<double>& uIn, const vector<double>& vIn, const vector<double>& YcvIn, const DamageModel& dmIn) {

    printRunInfo();

	//copy input variables
	E = Ein;
	rho = rhoIn;
	A = Ain;
	L = Lin;
	Yc = Ycin;
	dm = dmIn;
	nucleated = nucleatedIn;
	assert(sm == "LIN" || sm == "SQRT"); if (sm == "LIN") assert(dm.getType() == 2);

    Nnod = Nelt+1;
    _Nt = 0;
    double c = sqrt(E/rho);
    h = 1/static_cast<double>(Nelt) * L; //
    double cfl = 1./ts_refine;
    dt = cfl * h/c;//
    unsigned Ntim = static_cast<unsigned>(end_t/dt)+1;
    ec = sqrt(2 * Yc / E);
    sigc = E * ec;
	
	EPS = numeric_limits<double>::epsilon();
    d = vector<double>(Nnod,0);
    dE = vector<double>(Nelt,0);
    dE_1 = vector<double>(Nelt,0);
    d_max = vector<double>(Nnod,0);
    s = vector<double>(Nnod,0.0);
    sE = vector<double>(Nelt,0.0);
    energy = vector<double>(Nnod,0);
    Y = vector<double>(Nelt,0);
    Ybar = vector<double>(Nnod,0);
    Ycbar = vector<double>(Nnod,0);
    strain_energy = 0.0;
    kinetic_energy = 0.0;
    dissip_energy = 0.0;
    test_dissip_energy = 0.0;
    dissip_energy_local = 0.0;
    dissip_energy_TLS = 0.0;
    test_dissip_energy_TLS = 0.0;
    ext_energy = 0.0;
    tot_energy = 0.0;
	XFEM = true;
if (XFEM) assert(elemDeath == false);

uGL = vector<double>(Nelt,0);
uGR = vector<double>(Nelt,0);
uGL_1 = vector<double>(Nelt,0);
uGR_1 = vector<double>(Nelt,0);
vGL = vector<double>(Nelt,0);
vGR = vector<double>(Nelt,0);
vGL_1 = vector<double>(Nelt,0);
vGR_1 = vector<double>(Nelt,0);
aGL = vector<double>(Nelt,0);
aGR = vector<double>(Nelt,0);
aGL_1 = vector<double>(Nelt,0);
aGR_1 = vector<double>(Nelt,0);
eL = vector<double>(Nelt,0);
eR = vector<double>(Nelt,0);
dEL = vector<double>(Nelt,0);
dEL_1 = vector<double>(Nelt,0);
dER = vector<double>(Nelt,0);
dER_1 = vector<double>(Nelt,0);
sEL = vector<double>(Nelt,0);
sER = vector<double>(Nelt,0);
split = vector<double>(Nelt,-1);

    u = uIn;
    v = vIn;
    a = vector<double>(Nnod,0);
    a_1 = vector<double>(Nnod,0);
    v_1 = vector<double>(Nnod,0);
    u_1 = vector<double>(Nnod,0);
    phi = phiIn;

    phi_1 = vector<double>(Nnod,0);
    phidot = vector<double>(0);
    gradPhi = vector<double>(Nelt,0.0);
residualVec = vector<double>(maxIteration,0.0);
residualMax = vector<double>(maxIteration,0.0);
residualSum = vector<double>(maxIteration,0.0);

	nfrags = vector<unsigned>(1,0);  

    _numFrag = 0;
    vector<Segment*> segments;
	if (nucleated > 0) for (unsigned j = 0; j < segIn.size(); ++j) segments.push_back(segIn.at(j));

    m.assign(Nnod,rho*h*A);
    m[0] = m[0]/2; m[Nnod-1] = m[Nnod-1]/2;

    //initialization
	Ycv = YcvIn;
	e = eIn;
	x = xIn;

    xe = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nelt; ++j) xe[j] = 0.5*(x[j] + x[j+1]);

	if (frontExtension == 0) {
		t = vector<double>(1,0.0);     
	} else {
    	t = vector<double>(Ntim,0);
    	for (unsigned j = 0; j < Ntim; ++j) t[j] = static_cast<double>(j)*dt;
	}
    // Initially the bar is loaded and all elements are at Yc
    // A tls is placed on the first element, obviously it satifies
    //   Ybar = Yc
    // This extra damage will create new stress that are less than in the next element
    // and ill thus give an unloading wave.

    //constant strain rate applied

    //check to see which elements are in TLS zones
    inTLSnode.assign(Nnod,0);
	for (unsigned k = 0; k < segments.size(); ++k) {
		for (unsigned j = 0; j < segments[k]->size(); ++j) inTLSnode[segments[k]->indices[j]] = 1;
		setMin(segments[k]);
	}

    //calculate stresses
	calculateStresses(pg,wg);
    
	//acceleration
    a[0] = 0;
    a[Nnod-1] = 0;
    for (unsigned j = 1; j < Nnod-1; ++j)  a[j] = A*(sE[j] - sE[j-1]) /m[j];

    analyzeDamage(phi,h,segments);
    unsigned len = 0;
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l]->size() == 0) continue;
        len++;
    }
    phidot.resize(len);

    //print data to file
    vector<double>fragLength = findFragments(nfrags[0],segments);
    vector<double> Rinit (Nnod,0.0);
    vector<double> Tinit (Nnod, 0.0);	
	calculateYbar(Rinit,Tinit,pg,wg,phi);
    calculateEnergies(0,pg,wg);
    if (printVTK != 0) printVtk(_Nt);
    printFrags(fragLength,segments.size());
    printGlobalInfo();
	printResidual();

	assert(_Nt == 0);
	assert(t.size() >= _Nt + 1);   
			
	double dmin_old = 0.0;
 
	//time-integration loop
	while (t.at(_Nt) < end_t) {	//    for (unsigned i = 1; i < Ntim; ++i){
        _Nt++;
//cout << "t = " << t.at(_Nt) << endl;

		//if delay-damage model, find new dt
		if (frontExtension == 0) {
			//find time-step - damage
     		double dmin = min(d);
     		assert( dmin + 1.0e-8 > dmin_old);
     		if (dmin > dmin_old) dt =  cfl * h/c / sqrt(1.0 - dmin);
			dmin_old = dmin;
     		dt = min(cfl * h/c, dt);
 
     		//find time-step - level-set
    		vector<double> dphi(phi.size(),0);
     		if (_Nt > 1) {
         		double maxdphi = 0.0;
        		if (phidot.size() > 0) maxdphi = max(phidot);
        		if (maxdphi > 0) {
             		double dtL = h / maxdphi;
             		dt = min(dt, dtL);
         		}
     		}
 
     		//define time
     		t.push_back(t.back() + dt);
		} //end delay-damage find new dt

		Ybar.assign(Nnod,0.0);
		Ycbar.assign(Nnod,0.0);
		phidot.clear();


//check that split values are empty
for (unsigned i = 0; i < Nelt; ++i) {
	if (XFEM == 0) assert(split[i] == -1);
	if (split[i] == -1) {
		assert(uGL[i] == 0);
		assert(uGR[i] == 0);
		assert(uGL_1[i] == 0);
		assert(uGR_1[i] == 0);
		assert(vGL[i] == 0);
		assert(vGR[i] == 0);
		assert(vGL_1[i] == 0);
		assert(vGR_1[i] == 0);
		assert(aGL[i] == 0);
		assert(aGR[i] == 0);
		assert(aGL_1[i] == 0);
		assert(aGR_1[i] == 0);
		assert(eL[i] == 0);
		assert(eR[i] == 0);
		assert(dEL[i] == 0);
		assert(dEL_1[i] == 0);
		assert(dER[i] == 0);
		assert(dER_1[i] == 0);
		assert(sEL[i] == 0);
		assert(sER[i] == 0);
	} else {
		assert(split[i] >= 0);
		assert(split[i] <= 1);
	}
}

        //Copy kinematic variables to "old"
		u_1 = u; u.assign(Nnod,0.0);
		v_1 = v; v.assign(Nnod,0.0);
		a_1 = a; a.assign(Nnod,0.0);
		dE_1 = dE; dE.assign(Nelt,0.0);
        phi_1 = phi;

		uGL_1 = uGL; uGL.assign(Nelt,0.0);
		uGR_1 = uGR; uGR.assign(Nelt,0.0);
		vGL_1 = vGL; vGL.assign(Nelt,0.0);
		vGR_1 = vGR; vGR.assign(Nelt,0.0);
		aGL_1 = aGL; aGL.assign(Nelt,0.0);
		aGR_1 = aGR; aGR.assign(Nelt,0.0);
		dEL_1 = dEL; dEL.assign(Nelt,0.0);
		dER_1 = dER; dER.assign(Nelt,0.0);


        //prediction
//#pragma omp parallel for //OMP#1 
        for (unsigned j = 0; j < Nnod; ++j) {
            v[j]= v_1[j] + 0.5*dt*a_1[j];
            u[j]= u_1[j] + dt*v_1[j] + 0.5*dt*dt*a_1[j];
		}
	    for (unsigned j = 0; j < Nelt; ++j) {
			if (split[j] != -1) {
    	        vGL[j]= vGL_1[j] + 0.5*dt*aGL_1[j];
        	    vGR[j]= vGR_1[j] + 0.5*dt*aGR_1[j];
            	uGL[j]= uGL_1[j] + dt*vGL_1[j] + 0.5*dt*dt*aGL_1[j];
	            uGR[j]= uGR_1[j] + dt*vGR_1[j] + 0.5*dt*dt*aGR_1[j];
    	    }
		}

        //def computation and Y update.
//#pragma omp parallel for //OMP#2 
        for (unsigned j = 0; j < Nelt; ++j) {
            e[j] = (u[j+1] - u[j]) / h;
			if (split[j] != -1) {
	            eL[j] = (uGR[j] - u[j]) / h;
    	        eR[j] = (u[j+1] - uGL[j]) / h;
			}
        }

        //updating the stress and level-set fields
		//non-local / TLS
       	updateLevelSet(segments,pg,wg);
//    cout << t.at(_Nt) << " " << phi_1[46] << " " << phi[46] << " " << phi_1[46]/lc << " " << lc << endl;    
	calculateLevelSetGradient(gradPhi);
        //check for nucleation
		unsigned numNuc = 0;
   		if (TLSoption == 1){
	    	//local / non-local hybrid model
	    	unsigned elemOrNodal = 1; //"nodal";
	    	vector<double> gradLimit(1,1.0);
	    	numNuc = checkFailureCriteria(_Nt,gradLimit,elemOrNodal,gradPhi,true,true, segments, pg, wg);
	    } else {
			//unsupported option
			cout << " unsupported TLSoption : " << TLSoption << endl;
			assert(1==0);
		}

        int index = -1;
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l]->size() == 0) continue;
            index++;
            
			int smid = median(segments[l]->indices);

            len = 0;
            for (unsigned j = 0; j < segments.size(); ++j) {
                if (segments[j]->size() == 0) continue;
                len++;
            }
            phidot.resize(len);
            phidot.at(index) = (phi[smid] - phi_1[smid])/dt;
            if (numNuc > 0) phidot.at(index) = min(phidot.at(index), 1.0); //"hack", but for phidot plot, I don't need to see nucleation as 100000
            if (phidot[index] * dt > h*1.01 ) {
                printf("level-set front advancing more than one element per time-step: t=%f, segment %u , dphi/h = %f \n",t.at(_Nt),l,phidot[index]*dt/h);
            }
        }
    	
		analyzeDamage(phi,h,segments);
		splitElements();
       	calculateStresses(pg,wg);

		//save force on boundary required to make zero acceleration
		Fboundary = s.back()*A;

		//acceleration
        if (phi[0] <= lc) a[0] = 0;
        else a[0] =  A*sE[0]/m[0];
        a[Nnod-1] = 0; //note: this is a constraint which was hidden. if free, it would be -s(i,Nnod)/m(j);
//        a[Nnod-1] = A*( - sE[Nnod-1]) /m[Nnod-1];
//#pragma omp parallel for //OMP#4
        for (unsigned j = 1; j < Nnod - 1; ++j) {
			double stressL = sE[j-1];
			double stressR = sE[j];
			if (split[j-1] != -1) stressL = sER[j-1];
			if (split[j] != -1)   stressR = sEL[j];
			a[j] = A*(stressR - stressL) /m[j];
		}
        for (unsigned j = 0; j < Nelt; ++j) {
			if (split[j] == -1) continue;
			aGL[j] = A*sER[j] /m[j];
			aGR[j] = -A*sEL[j]/m[j+1];
		}

        //correction
//#pragma omp parallel for //OMP#5
        for (unsigned j = 0; j < Nnod; ++j) v[j]= v[j] + 0.5*dt*a[j];
        for (unsigned j = 0; j < Nelt; ++j) {
			if (split[j] == -1) continue;
			vGL[j]= vGL[j] + 0.5*dt*aGL[j];
			vGR[j]= vGR[j] + 0.5*dt*aGR[j];
		}

        //record number of fragments and quantities per fragment
        fragLength.clear();
        fragLength = findFragments(_numFrag,segments);
		nfrags.push_back(_numFrag); 

        //calculate energies
        calculateEnergies(_Nt,pg,wg);

        //update gradient for printing
		calculateLevelSetGradient(gradPhi);
        
		//check enforcement of constraints
        checkConstraints(gradPhi);
//cout << "  phi/LC = " << phi[Nelt/2]/lc  << "   d = " << d[Nelt/2] << endl;

		//print the rest of the table/graph data
        if (printVTK != 0) if ( ( _Nt % printVTK) == 0 ) {printVtk(_Nt); cout << "*t = " << t.at(_Nt) << endl;}
        printFrags(fragLength,segments.size());
        printGlobalInfo();
		printResidual();
        printForceDisp();

		if (frontExtension != 0 && _Nt == Ntim-1) break;
    }//end time-loop

	fragLength = localFragmentLength();

    //find fragment length total & minimum
    cout << " fragment lengths:" << endl;
    double minfrag = _fMin; 
	double sumfrag = 0.0;
    for (unsigned i = 0; i < fragLength.size(); ++i) {
        cout << fragLength[i] << endl;
		if (minfrag > fragLength[i] ) minfrag = fragLength[i];
		sumfrag += fragLength[i];
	}

    printf("Final number of fragments: %i \nMinimum fragment length: %3.3e    avg = %f\nFinal dissipated energy: %3.3e   = local %3.3e + TLS %3.3e  (%f/%f)\n",nfrags.back(),minfrag,sumfrag*L/static_cast<double>(nfrags.back()),dissip_energy,dissip_energy_local,dissip_energy_TLS,dissip_energy_local/dissip_energy,dissip_energy_TLS/dissip_energy);
    double alt_dissip_energy = 0.0 + ext_energy - strain_energy - kinetic_energy; 
    printf("alt. dissipated energy: %3.3e \n",alt_dissip_energy); 
    printf("alt. dissipated energy: %3.3e \n",test_dissip_energy); 
   cout << " fragment total length " << sumfrag << "     powder length = " << 2.0*L - sumfrag << endl;

    //print histogram
    printHisto(fragLength);

    //kill all segments
    killSegments(segments);

	//return displacement for testing
	uIn = u;

    return;
};

void PotentialAvenger::killSegments(vector<Segment*>& seg) {
    for (unsigned i = 0; i < seg.size(); ++i) delete seg[i];
    seg.clear();
    return;
}

void PotentialAvenger::splitElements() {

	if (XFEM == false) return;

	for (unsigned i = 0; i < Nelt; ++i) {
		//already split, don't care
		if (split[i] != -1) continue;

		//both nodes must be inTLS
		if (!inTLSnode[i]) continue;
		if (!inTLSnode[i+1]) continue;

		//above Lc, can't split
		if (min(phi[i], phi[i+1]) >= lc) continue;

		//simple crossing, don't split
		if ( (max(phi[i], phi[i+1]) >= lc) && (min(phi[i], phi[i+1]) <= lc)) continue;

		//if under Lc and projection is under Lc, don't split
		if ( 0.5*(phi[i] + phi[i+1] + h) < lc) continue;

		//crossed out all other cases, so split element
		cout << " phi/LC = " << phi[i]/lc << " , " << phi[i+1]/lc << endl;
		double delta = 0.5 * (phi[i+1] - phi[i] + h);
		cout << " delta = " << delta << "   c = " << 0.5 * (phi[i+1] + phi[i] + h) << endl;
		assert(delta >= 0); assert(delta <= h);
		double xSplit = x[i] + delta;
		
		split[i] = delta/h;
		uGL[i] = u[i];	
		uGR[i] = u[i+1];	
		vGL[i] = v[i];	
		vGR[i] = v[i+1];	
		aGL[i] = a[i];	
		aGR[i] = a[i+1];
		eL[i]  = e[i];	
		eR[i]  = e[i];	
		dEL[i]  = dE[i];	
		dEL_1[i]= dE_1[i];	
		dER[i]  = dE[i];	
		dER_1[i]= dE_1[i];	
		sEL[i]  = sE[i];	
		sER[i]  = sE[i];

		printf("split element (XFEM), t = %f, x_mid = %f, inTLSnode: %u,%u \n",t.at(_Nt),xSplit,inTLSnode[i],inTLSnode[i+1]);	
	}
	return;
}

void PotentialAvenger::calculateLevelSetGradient( vector<double>& gradientPhi) {
    //calculate the gradient of the levelset (non-local model). This will be used to see if the |gradPhi| > 1,
    //in which case, a non-local zone will be inserted
    assert(gradientPhi.size() == Nelt);

	//calculate gradient of level-set within elements of non-local zone
//#pragma omp parallel for //OMP#9b
	for (unsigned i = 0; i < Nelt; ++i) {
		gradientPhi[i] = (phi[i+1]-phi[i])/h;
	}
    return;
}


void PotentialAvenger::checkConstraints(const vector<double>& gradientPhi) {

	//check gradient of level-set
	assert(gradientPhi.size() == Nelt);
/*   
	if (TLSoption == 1 && minOpenDist == 0.0 && alpha > 0 && oneAtATime == 0) {
		for (unsigned j = 0; j < Nelt; ++j) {
			//if (j > 0) if (d[j] == 1.0 && d[j-1] == 1.0) continue;
			if (fabs(gradientPhi[j]) > 1.0 + 1.0e-8) cout << "  j = " << j << "   xe = " << xe[j] << "   grad = " << gradientPhi[j] << "   inTLSnode = " << inTLSnode[j] << " , " << inTLSnode[j+1] << endl;
			assert(fabs(gradientPhi[j]) < 1.0 + 1.0e-8);
		}
	}
*/
	//for all: check that Ybar <= Yc
	if (minOpenDist == 0.0 && frontExtension == 1) {
		for (unsigned j = 0; j < Nnod; ++j) assert(Ybar[j] <= 1.e-6);
	}
	
	return;
}

void PotentialAvenger::calculateStresses(const std::vector<double>& pg, const std::vector<double>& wg) {

	//nodal stress	
	s.assign(Nnod,0.0);

	for (unsigned i = 0; i < Nnod; ++i) {
		d[i] = dm.dval(phi[i]);
		double eAvg = nodalStrain(i);
		s[i] = E * eAvg * (1 - d[i]); //nodal 
	}
	
	//elemental stress (for newton's laws)
	sE.assign(Nelt,0.0);
	sEL.assign(Nelt,0.0);
	sER.assign(Nelt,0.0);

	for (unsigned i = 0; i < Nelt; ++i) {
		double intact = 1.0;
		double strainPos = max(e[i], 0.0);
		double strainNeg = min(e[i], 0.0);
		assert(strainPos + strainNeg == e[i]);
	
		double strainPosL = 0.0;
		double strainPosR = 0.0;
		double strainNegL = 0.0;
		double strainNegR = 0.0;
		if (split[i] != -1) {
			strainPosL = max(eL[i], 0.0);
			strainNegL = min(eL[i], 0.0);
			assert(strainPosL + strainNegL == eL[i]);
			strainPosR = max(eR[i], 0.0);
			strainNegR = min(eR[i], 0.0);
			assert(strainPosR + strainNegR == eR[i]);
		}
   
		for (unsigned q = 0; q < pg.size(); ++q) {

        	double philocal = phi[i+1] * (1.0-pg[q]) + phi[i] * pg[q];
			if (fullCompression) 	sE[i] += E * strainPos * (1.0 - dm.dval(philocal)) * wg[q] + E * strainNeg * wg[q];
			else					sE[i] += E * (strainPos + strainNeg) * (1.0 - dm.dval(philocal)) * wg[q];

			if (split[i] != -1) {
                //shift quadrature: phi+h -> split point h
                //there is another alternative: phi+h -> lc
	        	double philocalL = (phi[i]+h*split[i]) * (1.0-pg[q]) + phi[i] * pg[q];
    	    	double philocalR = phi[i+1] * (1.0-pg[q]) + (phi[i+1] + h*(1.0-split[i])) * pg[q];
				if (fullCompression) 	sEL[i] += E * strainPosL * (1.0 - dm.dval(philocalL)) * wg[q] + E * strainNegL * wg[q];
				else					sEL[i] += E * (strainPosL + strainNegL) * (1.0 - dm.dval(philocalL)) * wg[q];
				if (fullCompression) 	sER[i] += E * strainPosR * (1.0 - dm.dval(philocalR)) * wg[q] + E * strainNegR * wg[q];
				else					sER[i] += E * (strainPosR + strainNegR) * (1.0 - dm.dval(philocalR)) * wg[q];
			}
		}
		
		if ((phi[i] >= lc || phi[i+1] >= lc) ) intact = 0.0;
		sE[i] *= intact;
	}
	
	return;
}

double PotentialAvenger::nodalStrain(const unsigned&i ) {
	double eAvg = 0.0;

	if (i > 0 && i < Nnod-1) {
		eAvg = 0.5*(e[i] + e[i-1]);
	} else if (i == 0) {
		eAvg = e[i];
	} else if (i == Nnod-1) {
		eAvg = e[i-1];
	} else {
		assert(1==0);
	}

	return eAvg;
}
	
void PotentialAvenger::calculateEnergies(const unsigned& i, const std::vector<double>& pg, const std::vector<double>& wg) {
    dissip_energy = 0.0;
    test_dissip_energy = 0.0;
    kinetic_energy = 0.0;
	double KE = 0.0;
	double DETLS = dissip_energy_TLS;
	double test_DETLS = test_dissip_energy_TLS;
	double DEL = dissip_energy_local;
    simpleY = vector<double>(Nelt,0.0);
    vector<double> simpleYL = vector<double>(Nelt,0.0);
    vector<double> simpleYR = vector<double>(Nelt,0.0);
    vector<double> YL = vector<double>(Nelt,0.0);
    vector<double> YR = vector<double>(Nelt,0.0);
//#pragma omp parallel for reduction(+:DETLS,DEL,KE)//OMP#7
    for (unsigned j = 0; j < Nelt; ++j) {

		simpleY[j] = 0.5*E*e[j]*e[j];
		Y[j] = 0.5*E*e[j]*e[j];
		if (split[j] != -1) {
			simpleYL[j] = 0.5*E*eL[j]*eL[j];
			simpleYR[j] = 0.5*E*eR[j]*eR[j];
			simpleY[j] = 0.5*E*(split[j]*eL[j]*eL[j] + (1.0-split[j])*eR[j]*eR[j]);
			YL[j] = 0.5*E*eL[j]*eL[j];
			YR[j] = 0.5*E*eR[j]*eR[j];
			Y[j] = 0.5*E*(split[j]*eL[j]*eL[j] + (1.0-split[j])*eR[j]*eR[j]);
		}

		dE[j] = 0.0;
		if (split[j] != -1) {
			dEL[j] = 0.0;
			dER[j] = 0.0;
		}

		for (unsigned q = 0; q < pg.size(); ++q) {
			double philocal = phi[j+1] * (1.0-pg[q]) + phi[j] * pg[q];
			double Yclocal = Ycv[j+1] * (1.0-pg[q]) + Ycv[j] * pg[q];
			dE[j] += dm.dval(philocal) * wg[q];
			Y[j] -= dH(Yclocal, dm.dval(philocal)) * wg[q];

			if (split[j] != -1) {
				double philocalL = (phi[j]+h) * (1.0-pg[q]) + phi[j] * pg[q];
				double philocalR = phi[j+1] * (1.0-pg[q]) + (h+phi[j+1]) * pg[q];
				dEL[j] += dm.dval(philocalL) * wg[q];
				dER[j] += dm.dval(philocalR) * wg[q];
			    YL[j] -= dH(Yclocal, dm.dval(philocalL)) * wg[q];
			    YR[j] -= dH(Yclocal, dm.dval(philocalR)) * wg[q];
			}

		}

		if (elemDeath) {
			if (max(phi[j],phi[j+1]) >= lc) dE[j] = 1.0;
		}
/*		//this inf/nan checking is necessary with the LIN softening model
		//since dH can have a zero-denominator or be 0/0 if phi >= lc	
		if (isnan(Y[j]) == 1) Y[j] = Ycv[j];
		assert(isnan(Y[j]) == 0);
		if (isinf(Y[j]) == 1) Y[j] = Ycv[j];
		assert(isinf(Y[j]) == 0);
*/	/*	
		if (Ycbar[j] == 0.0) {
			assert(Ybar[j] == 0.0);
			Ycbar[j] = Ycv[j];
		}
*/
 		if (split[j] == -1) {
			if (inTLSnode[j]+inTLSnode[j+1] == 0) DEL += h * A * simpleY[j] * (dE[j] - dE_1[j]); //global dissipation = int: Y dd/dt dV
	        else DETLS += h * A * simpleY[j] * (dE[j] - dE_1[j]); //global dissipation = int: Y dd/dt dV
	        test_DETLS += h * A * Y[j] * (dE[j] - dE_1[j]); //global dissipation = int: Y dd/dt dV
			energy[j] = h * A * 0.5 * E * e[j] * e[j] * (1.0 - dE[j]);
		} else {
			if (inTLSnode[j]+inTLSnode[j+1] == 0) DEL += h * A * simpleY[j] * (dE[j] - dE_1[j]); //global dissipation = int: Y dd/dt dV
        	else DETLS += h * A * (split[j] * simpleYL[j] * (dEL[j] - dEL_1[j]) + (1.0 - split[j])*simpleYR[j]*(dER[j]-dER_1[j])); //global dissipation = int: Y dd/dt dV
			if (inTLSnode[j]+inTLSnode[j+1] == 0) test_DETLS += h * A * Y[j] * (dE[j] - dE_1[j]); //global dissipation = int: Y dd/dt dV
        	else test_DETLS += h * A * (split[j] * YL[j] * (dEL[j] - dEL_1[j]) + (1.0 - split[j])*YR[j]*(dER[j]-dER_1[j])); //global dissipation = int: Y dd/dt dV
			energy[j] = h * A * 0.5 * E * (split[j] * eL[j] * eL[j] * (1.0 - dEL[j]) + (1.0 - split[j]) * eR[j] * eR[j] * (1.0 - dER[j]));
		}
        KE += 0.5 * h * A * rho * 0.5 *(v[j]*v[j] + v[j+1] * v[j+1]);
        
    }
	
	kinetic_energy = KE;
	dissip_energy_TLS = DETLS;
	test_dissip_energy_TLS = test_DETLS;
	dissip_energy_local = DEL;
    //ustat(i,:) *= u(1,Nnod)/ustat(i,Nnod);
	dissip_energy = dissip_energy_local + dissip_energy_TLS;
	test_dissip_energy = test_dissip_energy_TLS;


    strain_energy = sum (energy);
    if (i > 0) ext_energy += (a.back() * m.back() + s.back() * A) * v.back() * dt;
    else ext_energy = dissip_energy + strain_energy + kinetic_energy;
    tot_energy = strain_energy + kinetic_energy + dissip_energy - ext_energy;
    max_energy = max(max(kinetic_energy,dissip_energy),strain_energy);
    return;
}

std::string convertInt(unsigned number) {
    if (number == 0)
        return "0";
    string temp="";
    string returnvalue="";
	//read from back
    while (number>0)
    {
        temp+=number%10+48;
        number/=10;
    }
    for (unsigned i=0;i<temp.length();i++)
        returnvalue+=temp[temp.length()-i-1];
    return returnvalue;
}

double PotentialAvenger::H (const unsigned j, const double phi) {
	return H(Ycv[j],phi);
}

double PotentialAvenger::H (const double Ycthis, const double phi) {
	double dee = dm.dval(phi);
	if (sm == "SQRT") return (Ycthis * alpha * dee * dee)/(1.0 - alpha * dee);
	if (sm == "LIN") {
		double p = max(phi,0.0)/lc;	
		double H = dee / pow(1.0 - p + alpha * p * p,2);	
		return Ycthis*(H-dee);
	}
	return 0;
}    

double PotentialAvenger::dH (const unsigned j, const double phi) { 
	return dH(Ycv[j], phi);
}

double PotentialAvenger::dH (const double Ycthis, const double phi) { 
	double dee = dm.dval(phi);
    if (sm == "SQRT") return (Ycthis * alpha * dee) * (2.0 - alpha * dee)/pow(1.0 - alpha * dee,2);
    if (sm == "LIN") {
		double p = max(phi,0.0)/lc;	
		double dHdp = 2*(alpha * pow(p, 3) - 3*alpha * pow(p,2) + 1) / pow(alpha * pow(p,2) - p + 1, 3);
		double dpdd = 0.5 / (1.0 - p); 
		double dH = dHdp * dpdd;
        return Ycthis * (dH - 1);
    }  
	return 0;
}    

double PotentialAvenger::d2H (const unsigned j, const double phi) {
	return d2H(Ycv[j], phi);
}

double PotentialAvenger::d2H (const double Ycthis, const double phi) {
	double dee = dm.dval(phi); 
    if (sm == "SQRT") return (2.0 * Ycthis * alpha) /pow(1.0 - alpha * dee,3);
    if (sm == "LIN") {
		double p = max(phi,0.0)/lc;	
		double d2Hdp2 = (4*pow(alpha,2)*pow(p,5) - 18*pow(alpha,2)*pow(p,4) + 12*pow(alpha,2)*pow(p,3) - alpha*pow(p,4) + 4*alpha*pow(p,3) + 10*alpha*pow(p,2) - 12*alpha*p - 4*p + 4)/(pow(p - 1,2)*pow(alpha*pow(p,2) - p + 1,4));
		double dpdd = 0.5 / (1.0 - p); 
		double d2H = d2Hdp2 * dpdd;
        return Ycthis * d2H;
    }  
	return 0;
}    

void PotentialAvenger::calculateYbar(vector<double>& R, vector<double>& Tdiag, const std::vector<double>& pg, const std::vector<double>& wg, const std::vector<double>& phi0) {

	R.assign(Nnod,0);
	Tdiag.assign(Nnod,0);
	Ybar.assign(Nnod,0);
	Ycbar.assign(Nnod,0);

	unsigned option = 0;
	//option (0):	philocal uses updated value of phi all the time
	//option (1):	philocal uses updated value of phi ONLY for node i; i-1 & i+1 use phi0
	//option (2):	philocal uses updated value of phi at node i to shift i-1 & i+1;

	//create nodal residual and tangent vectors
	cilk_for (unsigned i = 0; i < Nnod; ++i) {

	//calculate strain at node by weighted average of neighboring element strains by "solidity" (portion with phi < lc)
	double strain = 0.0;
	double length = 0.0;
	double solidLeft = 0.0;
	double solidRight = 0.0;
	if (i > 0) {
		//examine element to left
		solidLeft = elementSolid(i-1);
		strain += e[i-1] * solidLeft;
		length += solidLeft;
	}
	if (i < Nnod - 1) {
		//examine element to right
		solidRight = elementSolid(i);
		strain += e[i] * solidRight;
		length += solidRight;
	}
	if (length == 0.0) 			strain = 0.0;
	else						strain = strain/length;

		for (unsigned q = 0; q < pg.size(); ++q) {

			if (i > 0) {
				double strainL = e[i-1];

				if (split[i-1] != -1) strainL = eR[i-1];

				if (fullCompression) strain = max(strain, 0.0);
				if (fullCompression) strainL = max(strainL, 0.0);
//strainL = strain;
				double mode = pg[q];

				double philocal = 0.0;
				if (split[i-1] == -1) {
					if (option == 0) 		philocal = phi[i-1] * (1.0-pg[q]) + phi[i] * pg[q];
					else if (option == 1) 	philocal = phi0[i-1] * (1.0-pg[q]) + phi[i] * pg[q];
					else if (option == 2) 	philocal = phi0[i-1] * (1.0-pg[q]) + phi0[i] * pg[q] + (phi[i] - phi0[i]);
					else 					assert(1==0);
				} else {
					//shift quadrature: phi+h -> split point (1-split[i-1])*h
					//there is another alternative: phi+h -> lc
					if (option == 0) 		philocal = (phi[i]+(1-split[i-1])*h) * (1.0-pg[q]) + phi[i] * pg[q];
					else if (option == 1) 	philocal = (phi0[i]+(1-split[i-1])*h) * (1.0-pg[q]) + phi[i] * pg[q];
					else if (option == 2) 	philocal = (phi0[i]+(1-split[i-1])*h) * (1.0-pg[q]) + phi0[i] * pg[q] + (phi[i] - phi0[i]);
					else 					assert(1==0);
					mode = 1.0;
					solidLeft = max(min(lc - phi[i], h), 0.0); //(1.0 - split[i-1]) * h;
				}
				double Yclocal = Ycv[i-1] * (1.0-pg[q]) + Ycv[i] * pg[q]; 
				
				R[i] += (0.5*E*strainL*strainL - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode  * wg[q] * (solidLeft/h); //(element)
				Tdiag[i] += mode * wg[q] * ( (0.5*E*strainL*strainL - Yclocal - dH(Yclocal,philocal)) * dm.dpp(philocal) - d2H(Yclocal,philocal)*pow(dm.dp(philocal),2) ) * (solidLeft/h); //element
				Ybar[i] +=  (0.5*E*strainL*strainL - dH(Yclocal,philocal)) * dm.dp(philocal) * mode * wg[q] * (solidLeft/h); //element
				Ycbar[i] += Yclocal * dm.dp(philocal) * mode * wg[q] * (solidLeft/h);
//if (phi[i]/lc > 0.99 && phi[i] < 1.0) cout << "  " << i << "-" << q << " left:  R+= " << (0.5*E*strainL*strainL - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode  * wg[q] * (solidLeft/h) << "  0.5Eee = " << 0.5*E*strainL*strainL << " Yc = " << Yclocal << " dH = " << dH(Yclocal,philocal)  << "    dphi = " << dm.dp(philocal); 
//if (phi[i]/lc > 0.99 && phi[i] < 1.0) cout << " ------ alt = " << (0.5*E*strain*strain - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode  * wg[q] * (solidLeft/h) << "   0.5Eee' = " << 0.5*E*strain*strain << endl; 
//if (i == 5829 || i == 5830) cout << "  " << i << "-" << q << " left:  R+= " << (0.5*E*strainL*strainL - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode  * wg[q] * (solidLeft/h) << "  0.5Eee = " << 0.5*E*strainL*strainL << " Yc = " << Yclocal << " dH = " << dH(Yclocal,philocal)  << "    dphi = " << dm.dp(philocal); 
//if (i == 5829 || i == 5830) cout << " ------ alt = " << (0.5*E*strain*strain - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode  * wg[q] * (solidLeft/h) << "   0.5Eee' = " << 0.5*E*strain*strain << endl; 
//if (i == 35) cout << " left:  T+= " << mode * wg[q] * ( (0.5*E*strainL*strainL - Yclocal - dH(Yclocal,philocal)) * dm.dpp(philocal) - d2H(Yclocal,philocal)*pow(dm.dp(philocal),2) ) * (solidLeft/h     ) << "   d2H = " << d2H(Yclocal,philocal) << endl; 
			}
			if (i < Nnod-1) {	
				double strainR = e[i];

				if (split[i] != -1) strainR = eL[i];

				if (fullCompression) strain = max(strain, 0.0);
				if (fullCompression) strainR = max(strainR, 0.0);
//strainR = strain;
				double mode = pg[q];
			
				double philocal = 0.0;
				if (split[i] == -1) {	
					if (option == 0) 		philocal = phi[i+1] * (1.0-pg[q]) + phi[i] * pg[q];
					else if (option == 1) 	philocal = phi0[i+1] * (1.0-pg[q]) + phi[i] * pg[q];
					else if (option == 2) 	philocal = phi0[i+1] * (1.0-pg[q]) + phi0[i] * pg[q] + (phi[i] - phi0[i]);
					else 					assert(1==0);
				} else {
					//shift quadrature: phi+h -> split point split[i-1]*h
					//there is another alternative: phi+h -> lc
					if (option == 0) 		philocal = (phi[i]+h*split[i]) * (1.0-pg[q]) + phi[i] * pg[q];
					else if (option == 1) 	philocal = (phi0[i]+h*split[i]) * (1.0-pg[q]) + phi[i] * pg[q];
					else if (option == 2) 	philocal = (phi0[i]+h*split[i]) * (1.0-pg[q]) + phi0[i] * pg[q] + (phi[i] - phi0[i]);
					else 					assert(1==0);
					mode = 1.0;
					solidRight = max(min(lc - phi[i], h), 0.0); //split[i] * h;
				} 
				double Yclocal = Ycv[i+1] * (1.0-pg[q]) + Ycv[i] * pg[q]; 
				R[i] += (0.5*E*strainR*strainR - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode * wg[q] * (solidRight/h); //(element)
				Tdiag[i] += mode * wg[q] * ( (0.5*E*strainR*strainR - Yclocal - dH(Yclocal,philocal)) * dm.dpp(philocal) - d2H(Yclocal,philocal)*pow(dm.dp(philocal),2) )  * (solidRight/h); //element
				Ybar[i] += (0.5*E*strainR*strainR - dH(Yclocal,philocal)) * dm.dp(philocal) * mode * wg[q] * (solidRight/h); //element
				Ycbar[i] += Yclocal * dm.dp(philocal) * mode * wg[q] * (solidRight/h); //element
//if (phi[i]/lc > 0.99 && phi[i] < 1.0) cout << "  " << i << "-" << q << " right:  R+= " << (0.5*E*strainR*strainR - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode  * wg[q] * (solidLeft/h) << "  0.5Eee = " << 0.5*E*strainR*strainR << " Yc = " << Yclocal << " dH = " << dH(Yclocal,philocal) << "    dphi = " << dm.dp(philocal);
//if (phi[i]/lc > 0.99 && phi[i] < 1.0) cout <<  " ------- alt = " << (0.5*E*strain*strain - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode * wg[q] * (solidRight/h) << "   0.5Eee' = " << 0.5*E*strain*strain << endl;
//if (i == 5829 || i == 5830) cout << "  " << i << "-" << q << " right:  R+= " << (0.5*E*strainR*strainR - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode  * wg[q] * (solidLeft/h) << "  0.5Eee = " << 0.5*E*strainR*strainR << " Yc = " << Yclocal << " dH = " << dH(Yclocal,philocal) << "    dphi = " << dm.dp(philocal);
//if (i == 5829 || i == 5830) cout <<  " ------- alt = " << (0.5*E*strain*strain - Yclocal - dH(Yclocal,philocal)) * dm.dp(philocal) * mode * wg[q] * (solidRight/h) << "   0.5Eee' = " << 0.5*E*strain*strain << endl;
//if (i == 35) cout << " right:  T+= " << mode * wg[q] * ( (0.5*E*strainR*strainR - Yclocal - dH(Yclocal,philocal)) * dm.dpp(philocal) - d2H(Yclocal,philocal)*pow(dm.dp(philocal),2) ) * (solidLeft/h     ) << "   d2H = " << d2H(Yclocal,philocal) << endl; 
			}
			
		} //over quadrature points
//if (i == 35) cout << " -->R= " << R[i] << "      Ralt = " << Ralt[i] << endl; 
//if (i == 35) cout << " -->T= " << Tdiag[i] << "      Talt = " << Talt[i] << endl; 
//if (i == 35) cout << " --alt---> dphiAlt = " << -Ralt[i]/Talt[i] << endl; 
//if (-R[i]/Tdiag[i] > 0 && -R[i]/Tdiag[i] > -Ralt[i]/Talt[i]) cout << "   dphi = " << -R[i]/Tdiag[i] << " --alt---> dphiAlt = " << -Ralt[i]/Talt[i] << endl; 
	}	//over nodes


	return;
}

void PotentialAvenger::updateLevelSet(vector<Segment*>& segments, const std::vector<double>& pg, const std::vector<double>& wg) {
	//non-local nodes   

	residualVec.assign(maxIteration,0.0);
	residualMax.assign(maxIteration,0.0);
	residualSum.assign(maxIteration,0.0);

	//R = (Y-Yc)*d'* phi^*
	//T = phi^* * [-Yc*Hdd*(d')^2 + (1/2*E*e^2 - Yc*Hd)d'']

	//assuming Ycv is nodal, H,d at node (exact integration)
	//could assume Ycv is elemental and H,d/H,dd integrated over element) - it's important that they be consistent
	assert(pg.size() == wg.size());
//if (segments.size() > 0) cout << endl;
	vector<double> R0;
	vector<double> phi0 = phi;
	vector<double> Tdiag0;
	for (unsigned j = 0; j < maxIteration; ++j) {
//if (segments.size() > 0) cout << " *iter " << j << endl;
		vector<double> R (Nnod,0.0);
		vector<double> Tdiag (Nnod, 0.0);	
		
		calculateYbar(R,Tdiag,pg,wg,phi0);	

		//gather for non-local solve R,T,Ybar
		//non-local information gather/scatter
		for (unsigned k = 0; k < segments.size(); ++k) {
			double Rval = 0.0;
			double Tval = 0.0;
			double Ybarval = 0.0;
			double Ycbarval = 0.0;
			//gather
			for (unsigned m = 0; m < segments[k]->size(); ++m) {
				unsigned index = segments[k]->indices[m];
//if (k <= 1) cout << j << "  k = " << k << " Rval + " << R[index] << "  Tval + " << Tdiag[index] << endl;
				Rval += R[index];
				Tval += Tdiag[index];
				Ybarval += Ybar[index];
				Ycbarval += Ycbar[index];
			}

			if (Tval == 0.0 && Rval == 0.0) {Tval = 1.0; Ycbarval = Ycv[segments[k]->indices[0]];}
			assert(Tval != 0.0);
//if (k <= 1) cout << j << "  k = " << k << " Rval = " << Rval << "  Tval = " << Tval << endl;
			//scatter
			for (unsigned m = 0; m < segments[k]->size(); ++m) {
				unsigned index = segments[k]->indices[m];
				R[index] = Rval;
				Tdiag[index] = Tval;
				Ybar[index] = Ybarval;
				Ycbar[index] = Ycbarval;
			}
/*
if ( segments[k]->phipeak/lc > 0.99 && segments[k]->phipeak/lc < 1.0 ) {
//if ( (-Raltval/Taltval > -Rval/Tval) && (-Raltval/Taltval > 0) ) {
cout << " segment " << k << " : " << segments[k]->begin() << "-" << segments[k]->end() << " phimax = " << segments[k]->phipeak-phi0[segments[k]->indices[0]]+phi[segments[k]->indices[0]] << endl;
cout << "                                     R = " << Rval << "        T = " << Tval << "    dphi = " << -Rval/Tval << endl; 
cout << "                                  altR = " << Raltval << "     altT = " << Taltval << "    altDphi = " << -Raltval/Taltval << endl; 
}*/
		}

		if (j == 0) R0 = R;
		for (unsigned i = 0; i < Nnod; ++i) {
			if (Tdiag[i] == 0.0 && R[i] == 0.0) Tdiag[i] = 1.0;
			if (Ybar[i] == 0.0 && Ycbar[i] == 0.0) Ycbar[i] = Ycv[i];
			assert(Tdiag[i] != 0.0);
			assert(Ycbar[i] != 0.0);
		}

		for (unsigned i = 0; i < Nnod; ++i) {
 			phi[i] -= R[i]/Tdiag[i];
			phi[i] = max(phi0[i],phi[i]);
//if (i == 35) cout << "  *** iter " << j << "  phi = " << phi[35] << "    dphi = " << -R[i]/Tdiag[i] << endl; 
			if (isnan(phi[i]) != 0) {cout << R[i] << "  " << Tdiag[i] << endl; assert(1==0);} 
			if (i == 0 && R0[i] > 0) residualVec[j] = R[i];
			if (R0[i] > 0) residualMax[j] = max(fabs(R[i]), residualMax[j]);
			if (R0[i] > 0) residualSum[j] += fabs(R[i]); //nodal

		}

	} // end iterations

	for (unsigned i = 0; i < Nnod; ++i) phi[i] = max(phi[i],phi0[i]);
/*if (segments.size() >= 2) {
double phimax = 0.0;
for (unsigned m = 0; m < segments[0]->size(); ++m) if (phi[segments[0]->indices[m]] > phimax) phimax = phi[segments[0]->indices[m]];
cout << "   ---> segment " << 0 << "  dphi = " << phi[segments[0]->indices[0]] - phi0[segments[0]->indices[0]] << "   phimax = " << phimax << endl; 
phimax = 0.0;
for (unsigned m = 0; m < segments[1]->size(); ++m) if (phi[segments[1]->indices[m]] > phimax) phimax = phi[segments[1]->indices[m]];
cout << "   ---> segment " << 1 << "  dphi = " << phi[segments[1]->indices[0]] - phi0[segments[1]->indices[0]] << "   phimax = " << phimax << endl;
}*/
    
	return;
}


void PotentialAvenger::setMin(Segment* segment) {
	assert(segment->size() > 0);


	double xmin = x[segment->indices[0]];
	double xmax = x[segment->indices[0]];
	double phimin = phi[segment->indices[0]];
	double phimax = phi[segment->indices[0]];
	for (unsigned i = 1; i < segment->size(); ++i) {
		unsigned index = segment->indices[i];
		if (phi[index] > phimax) {
			phimax = phi[index];
			xmax = x[index];
		}
		if (phi[index] < phimin) {
			phimin = phi[index];
			xmin = x[index];
		}
	}
	
	segment->xmin = xmin;	//x-location of phiMin
	segment->xpeak = xmax;	//x-location of phiMax
	segment->phimin = phimin;	//min of phi
	segment->phipeak = phimax; //max of phi

	return;
}

double PotentialAvenger::calculateZero (Segment* segment, const vector<double>& phiIn) {
	//calculate where along this segment the zero is
	double slope = segment->slope;
	
	assert(fabs(slope) == 1.0);
	assert(segment->size() > 0);
	unsigned sbegin = segment->begin();

	double zero = x[sbegin] - phiIn[sbegin] / slope;
 
	return zero;
}

double PotentialAvenger::calculateTotal (Segment* segment, const vector<double>& phiIn) {
	//calculate where along this segment total damage (lc) is
    double slope = segment->slope;

    assert(fabs(slope) == 1.0);
    assert(segment->size() > 0);
    unsigned sbegin = segment->begin();

    double total = x[sbegin] - (phiIn[sbegin] - lc) / slope;

    return total;
}

template <typename T> bool contains (const vector<T>& v, const T& item) {
	if(std::find(v.begin(), v.end(), item) != v.end()) {
		return true;
	} else {
		return false;
	}
}

void PotentialAvenger::nucleate(const double time, const std::vector<unsigned>& indexnuc, std::vector<Segment*>& newSegment, const unsigned& elemOrNodal){
    //time   -time
    //x      -mesh
    //phi    -level-set calculated at this time-step
    //indexnuc-index/indices of localizations to be nucleated: ELEMENT number. make sure both left and right are inTLS
	//elemOrNodal - elem(0) or nodal(1)

//change from L to NL
//add to segment
//update segment to regard new value as minimum if true

    assert(indexnuc.size() > 0);

    for (unsigned i = 0; i < indexnuc.size(); ++i) {
        nucleated++;

		//assert( inTLSnode[indexnuc[i]]*inTLSnode[indexnuc[i]+1]==0 );

		//need to join with NL zone with which the gradient > 1
//find the segment it belongs to, join with it or make one if it doesn't exist
		unsigned segphimin;
		double elemSlope = 0;
		if (phi[i+1] > phi[i]) elemSlope = 1;
		else elemSlope = -1;
	
		if (inTLSnode[indexnuc[i]] == 1) {
			segphimin = findSegmentOfNode(newSegment, indexnuc[i]);	
//        	newSegment[segphimin]->indices.push_back(indexnuc[i]+1);
			if (elemSlope == newSegment[segphimin]->slope) {
				//join if exists & same slope
				newSegment[segphimin]->indices.push_back(indexnuc[i]+1);
			} else {
				//make new NL zone if not
 				nucleateElement(indexnuc[i], newSegment);
				segphimin = newSegment.size()-1;
			}
		} else if (inTLSnode[indexnuc[i]+1] == 1) {
			segphimin = findSegmentOfNode(newSegment, indexnuc[i]+1);
			if (elemSlope == newSegment[segphimin]->slope) {
				//join if exists & same slope
				newSegment[segphimin]->indices.push_back(indexnuc[i]);
			} else {
				//make new NL zone if not
 				nucleateElement(indexnuc[i], newSegment);
				segphimin = newSegment.size()-1;
			}
		} else {
			//make one if it doesn't exist
			nucleateElement(indexnuc[i], newSegment);
			segphimin = newSegment.size() - 1;
		}

        //set gradient = 1 by adjusting phi
        if (elemSlope == 1) phi[i] = phi[i+1] - h;
        else phi[i+1] = phi[i] - h;

		sort(newSegment[segphimin]->indices.begin(),newSegment[segphimin]->indices.end());	
 
		setMin(newSegment[segphimin]);        

		inTLSnode[indexnuc[i]] = 1;
		inTLSnode[indexnuc[i]+1] = 1;

		printf("crack nucleated, t = %f, x = %f \n",time,x[indexnuc[i]]);
        
    }
};

void PotentialAvenger::nucleateElement(unsigned i, std::vector<Segment*>& newSegment) {
	Segment* seg = new Segment();
   	seg->indices.push_back(i);
   	seg->indices.push_back(i+1);
	if (phi[i+1] > phi[i]) seg->slope = 1;
	else seg->slope = -1;
	newSegment.push_back(seg);

	return;
}

unsigned PotentialAvenger::findSegmentOfNode( const vector<Segment*>& segments, const unsigned& value) {
	int segmentNum = -1;
	for (unsigned i = 0; i < segments.size(); ++i) {
		if (static_cast<int>(value) >= segments[i]->indices.front() && static_cast<int>(value) <= segments[i]->indices.back()) {
			segmentNum = static_cast<int>(i);
			break;
		}

	}
	if (segmentNum == -1) cout << " value = " << value << endl;
	assert(segmentNum >= 0);
	return static_cast<unsigned>(segmentNum);

}

vector<double> PotentialAvenger::findFragments(unsigned& nfrags, const vector<Segment*>& segments) {
    
    //calculate total number of fragments (removing symmetry simplification)
//    vector<double> fragLength = fragmentLength(segments); 
    vector<double> fragLength = localFragmentLength(); 
    nfrags = fragLength.size();
    fragmentStats(fragLength);   

    return fragLength; 
};

double PotentialAvenger::elementSolid(const unsigned& j) {
	double solid = 0.0;
	assert(j >= 0);
	assert(j < Nelt);

	//simple nodal method	
	if (max(phi[j], phi[j+1]) < lc) solid = h;
	else if (min(phi[j], phi[j+1]) > lc) solid = 0.0;
	else {
		double dx = h * (lc - phi[j])/(phi[j+1]-phi[j]);
		
		if (dx < 0.0) cout << " phi = " << phi[j] << " , " << phi[j+1] << "   dx= " << dx << endl; 
		assert(dx >= 0.0); assert(dx <= h);
	
		if (phi[j] <= lc && phi[j+1] >= lc)			solid = dx; 
		else if (phi[j] >= lc && phi[j+1] <= lc)		solid = h-dx; 
		else if (phi[j] == phi[j+1])				solid = 0.0;
		else {cout << " phi = " << phi[j] << " , " << phi[j+1] << "   j = " << j << endl; assert(1==0);}
	}
	return solid; 
}
	
vector<double> PotentialAvenger::localFragmentLength() {
    vector<double> fragLength;

	double powder = 0.0;
	double length = 0.0;
	for (unsigned j = 0; j < Nelt; ++j) {
		double solid = 0.0;

if (!XFEM) {
		//simple nodal method	
		solid = elementSolid(j);	
	
		solid = max(min(solid, h), 0.0);
		length += solid;
		if ( (phi[j+1] >= lc && length > 0) || j == Nelt-1) {
			fragLength.push_back(length);
			length = 0.0;
		}
		powder += h - solid;
} else {
		//new method using XFEM
//if (max(phi[j], phi[j+1]) > 0) if (j == 4999) cout << "  elem " << j << "  split = " << split[j] << endl;
		if (split[j] == -1) {
			if (max(phi[j], phi[j+1]) < lc) {
//if (j == 4999) if (max(phi[j], phi[j+1]) > 0) cout << " undamaged" << endl;
				solid = h;
				length += solid;
			}
			else if (min(phi[j], phi[j+1]) >= lc) {
//if (j == 4999) cout << " fully damaged" << endl;
				solid = 0.0;
				powder += h;
			}
			else if ( (max(phi[j], phi[j+1]) >= lc) && (min(phi[j], phi[j+1]) <= lc)) {
//if (j == 4999) cout << " crossing" << endl;
				//simple failure
				solid = elementSolid(j);	
				
				length += solid;
				powder += h - solid;
				if (phi[j] < phi[j+1]) {
//if (j == 4999) cout << " --upcrossing = new frag" << endl;
					fragLength.push_back(length);
					length = 0.0;
				}
			} else assert(1==0);
		} else {
			//XFEM

if ( 0.5*(phi[j] + phi[j+1] + h) > lc) {

			solid = max(min(lc - phi[j], h), 0.0);
			double elemSolid = solid; 
//cout << " XFEM : split = " << split[j] << endl;
//cout << "   solid1 = " << solid << endl;
	
			length += solid;

//			if (solid < h) {
				fragLength.push_back(length);
				length = 0.0;
//			}

			solid = max(min(lc - phi[j+1], h), 0.0);
			elemSolid += solid;
			length = solid;
//cout << "   solid2 = " << solid << endl;
if (elemSolid > h) cout << "   phi = " << phi[j] << " - " << phi[j+1] << "  lc = " << lc << "  h =  " << h <<  "   elemSolid = " << elemSolid << endl;
assert(elemSolid >= 0); assert(elemSolid <= h);
//elemSolid = max(min(elemSolid, h), 0.0);
			powder += h - elemSolid; 
} else {
			//not sure how you get here....
			solid = h;
			powder += 0.0;
			length += solid;

}


		}
}
		
		if (j == Nelt-1) {
			fragLength.push_back(length);
			length = 0.0;
		}
//		powder += h - solid;

	}

	//remove too-small fragments
	vector<double>::iterator iter;
	for (iter = fragLength.begin(); iter != fragLength.end(); ) {
		assert(*iter >= 0.0);
    	if (*iter < h) {
			powder += *iter;
        	iter = fragLength.erase(iter);
   		} else {
        	++iter;
		}
	}

	//duplicate
	powder *= 2.0;
	unsigned count = fragLength.size();
	for (unsigned j = 0; j < count; ++j) {
		if (j == 0 && d[j] < 1) fragLength[j] *= 2.0; 
		else fragLength.push_back(fragLength[j]);
	}

	//length check
    double sumfrag = 0.0;
	for (unsigned j = 0; j < fragLength.size(); ++j) 	sumfrag += fragLength[j];
	if (fabs(sumfrag + powder - L * 2.0) >= 0.001 * h) cout << " sumfrag = " << sumfrag << "     powder = " << powder << "    total = " << sumfrag + powder << "    diff = " << sumfrag+powder-2*L << endl;
	assert(fabs(sumfrag + powder - L * 2.0) < 0.001 * h );
    
	return fragLength;
}

unsigned PotentialAvenger::checkFailureCriteria(const unsigned ts, std::vector<double>& criterion, const unsigned& elemOrNodal, const std::vector<double>& qty, const bool absOrAsIs, const bool phiPos, std::vector<Segment*>& newSegment, const vector<double>& pg, const vector<double>& wg){

    //x              -mesh
    //phi            -level-set calculated at this time-step
    //criterion      -criterion to compare against for failure
    //elemOrNodal    -either 'elem'(0) or 'nodal'(1) - is criterion elemental or nodal
    //qty            -the quantity to be compared to the criterion -e.g. s,Y
    //absOrAsIs      -whether to compare (0) qty or (1) abs(qty) to criterion
    //phiPos         -whether(1) or not(0) failure cannot occur depending on if phi>0
    //failure if qty > criterion
	//return: xlist - number of nucleations performed

    vector<double> margin;
    vector<unsigned> index;

    assert(elemOrNodal == 1 || elemOrNodal == 0);
    assert(absOrAsIs == false || absOrAsIs == true);
    if (elemOrNodal == 1) {
        assert(x.size()-1 == qty.size());
    } else {
    	assert(1 == 0);
	}
    assert((qty.size() == criterion.size()) || (criterion.size() == 1));

    if (criterion.size() == 1) {
        double val = criterion[0];
        criterion.assign(qty.size(),val);
    }
    for (unsigned i = 0; i < qty.size(); ++i) {
        
		double qtyc = qty[i];
		//can't fail if already nucleated
		if (inTLSnode[i] + inTLSnode[i+1] == 2) continue;

		//compare against already accepted nucleation sites - xlist
		if (minOpenDist > 0.0) {
        	for (unsigned j = 0; j < index.size(); ++j) {
    	        if (elemOrNodal == 1) {
	                if (fabs(xe[index[j]]-xe[i]) < minOpenDist) goto nextLoop;
            	} else {
					assert( 1 == 0);
    	        }
  	    	}
		}
		
		if (absOrAsIs) {
            qtyc = fabs(qtyc);
        }

        if (qtyc > criterion[i]) {
            margin.push_back(qtyc/criterion[i]);
            index.push_back(i);
        }

        nextLoop: //jump to here if can't nucleate
        qtyc = 0;
    }


    //limited to one nucleation per timestep - IF OneAtATime=true
    if (oneAtATime) {
        double marmax = 0;
        unsigned indexMax = 0;
        if (index.size() > 0){
            for (unsigned i = 0; i < index.size(); ++i) {
                if (margin[i] > marmax) {
                    marmax = margin[i];
                    indexMax = i;
                }
            }
            unsigned temp1 = index[indexMax];
            index.clear(); index.push_back(temp1);
            margin.clear(); margin.push_back(marmax);
        }
        assert(index.size() <= 1);
    }
   
 
    //nucleate list
    if (index.size() > 0) {
        nucleate(t.at(ts),index, newSegment, elemOrNodal);
    }
	return index.size();
};

void PotentialAvenger::mergeIndices(vector<int>& a, vector<int>& b) {
	//from https://stackoverflow.com/questions/5958169/how-to-merge-two-sorted-arrays-into-a-sorted-array
	vector<int> answer (a.size()+b.size());
	int i = a.size() - 1; int j = b.size() - 1; int k = answer.size();

    while (k > 0)
        answer[--k] = 
            (j < 0 || (i >= 0 && a[i] >= b[j])) ? a[i--] : b[j--];

	a = answer;
	b.resize(0);	
	return;
}

void PotentialAvenger::analyzeDamage(vector<double>& phiV, const double h, vector<Segment*>& newSegment) {
    //produce:
    //new phi based on distances from Minima

    //if all negative one, skip
    unsigned sum = sumU(inTLSnode);
    if (sum == 0) return;

    sort(newSegment.begin(), newSegment.end(),SegmentComparer());
   
    assert(x.size() >= 1);

    //simply use pre-defined segments
    if (newSegment.size() == 0) return;

    unsigned nSegs = newSegment.size();
	
	vector<vector<int> > oldIndices (nSegs);
	for (unsigned i = 0; i < nSegs; ++i) {
		setMin(newSegment[i]);
		oldIndices[i] = newSegment[i]->indices;
		newSegment[i]->indices.clear();
	}

    //re-define segments.indices and phi
    vector<double> phinew = vector<double>(phiV.size(),-1);
   
//#pragma omp parallel for 
	for (unsigned i = 0; i < phiV.size(); ++i) {

		if (inTLSnode[i] == 0) continue;
        
		int segphimin = -1;
        double min = std::numeric_limits<double>::max(); 
        int altsegphimin = -1;
        double altmin = std::numeric_limits<double>::lowest();

        for (unsigned k = 0; k < nSegs; ++k) {
			if ( (x[i] - newSegment[k]->xmin)*newSegment[k]->slope < 0) {
				double altqty = newSegment[k]->phimin + newSegment[k]->slope*(x[i] - newSegment[k]->xmin);
//if (i == 414) cout << "   segment " << k << "   xmin = " << newSegment[k]->xmin << "  phimin = " << newSegment[k]->phimin << "   slope = " <<  newSegment[k]->slope << endl;
//if (i == 414) cout << "       altqty = " << altqty << endl; 
				if (altqty > altmin) {
					altmin = altqty;
					altsegphimin = k;
				}
				continue;
			}
            
			double qty = newSegment[k]->phimin + newSegment[k]->slope*(x[i] - newSegment[k]->xmin);
//if (i == 414) cout << "       qty = " << qty << endl; 
            if (qty < min) {
                min = qty;
                segphimin = k;
            }
        }
        
		assert(segphimin > -1);

		if (altmin > min) {
			min = altmin;
			segphimin = altsegphimin;
		}
//if (i == 414) cout << "      selection = " << min << endl; 
		assert(segphimin > -1);

		phinew[i] = min;

       	newSegment[segphimin]->indices.push_back(i);
    }

//    for (unsigned i = 0; i < Nnod; ++i) phinew[i] = max(phinew[i],phiV[i]);
//cout << "      final = " << phinew[414] << endl; 

	//sort segments
    sort(newSegment.begin(), newSegment.end(),SegmentComparer());

	//make sure segments don't overlap -- graph problem: discover connections, combine, delete;   reduce sorting: maybe sort all before, and only on combine?
    unsigned tot_indices = 0;
    for (unsigned i = 0; i < newSegment.size(); ++i) tot_indices += newSegment[i]->size();
if (tot_indices != sumU(inTLSnode)) cout << " tot_indices = " << tot_indices << "   nSeg = " << newSegment.size() << "    sum(inTLS) = " << sumU(inTLSnode) << endl;
    assert(tot_indices == sumU(inTLSnode));
	nSegs= newSegment.size();
	for (int i = 0; i < static_cast<int>(newSegment.size())-1; ++i) {
	//for (int i = 0; i < static_cast<int>(nSegs)-1; ++i) {

		if (newSegment[i]->size() > 0) {
			bool compact = ((int)newSegment[i]->size() - 1 == newSegment[i]->indices.back() - newSegment[i]->indices.front() );
					unsigned count = 0;
					while (!compact) {
						assert(newSegment[i]->size() > 1);
						if (count == 0) {
							//make new segment
							Segment* seg = new Segment();
							seg->indices.push_back(newSegment[i]->indices.back());
							seg->slope = newSegment[i]->slope;
							newSegment[i]->indices.pop_back();
							newSegment.push_back(seg);
						} else {
							newSegment.back()->indices.push_back(newSegment[i]->indices.back());
							newSegment[i]->indices.pop_back();
							sort(newSegment.back()->indices.begin(),newSegment.back()->indices.end());
						}
						count++;
						compact = ((int)newSegment[i]->size() - 1 == newSegment[i]->indices.back() - newSegment[i]->indices.front() );
					} //endwhile

		}
	}
/**/
    //delete empty segments
    vector<unsigned> delList;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        if (newSegment[i]->size() == 0) {                            //delete empty
            delList.push_back(i);
            continue;
        }

        assert(newSegment[i]->slope != 0);
    }
    while (delList.size() > 0) {
        unsigned index = delList.back();
        delete newSegment.at(index);
        newSegment.erase(newSegment.begin() + index);
        delList.pop_back();
    }	

    tot_indices = 0;
    sort(newSegment.begin(),newSegment.end(),SegmentComparer());
    for (unsigned i = 0; i < newSegment.size(); ++i) {
assert(newSegment[i]->size() > 0);
		setMin(newSegment[i]);
        tot_indices += newSegment[i]->size();
        if (newSegment[i]->phipeak> 0 ) assert(newSegment[i]->indices.size() <= x.size());
    }

if (tot_indices != sumU(inTLSnode)) cout << " tot_indices = " << tot_indices << "   nSeg = " << newSegment.size() << "    sum(inTLS) = " << sumU(inTLSnode) << endl;
    assert(tot_indices == sumU(inTLSnode));

    //return phinew as phi
    for (unsigned i = 0; i < phiV.size(); ++i) {
        if (inTLSnode[i]) phiV[i] = phinew[i];
    }

    if (nucleated == 0) assert(nSegs == newSegment.size());
    
};  

void PotentialAvenger::printRunInfo() {
    cout << endl;
    cout << "Run Info:" << endl;
    cout << "Strain rate = " << strain_rate << endl;
    cout << "# Elements = " << Nelt << endl;
    cout << "End Time (s) = " << end_t << endl;
    cout << "Time-step refinement ratio = " << ts_refine << endl;
    cout << "Damage gradient length (lc) = " << lc << endl;
    cout << "Beginning run... " << endl;
    cout << endl;

};

void PotentialAvenger::plotEnergies () {
    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgDissip.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'Wdissip' w l, \\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:8 ti 'local' w l, \\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:9 ti 'non-local' w l \n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:4 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:(abs($7)) ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:6 ti '0.01 * Wmax' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );

    fprintf( pFileW, "set output './pngFiles/enrgAll.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:3 ti 'Wdis' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'Wext' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:(abs($2+$3+$5)) ti 'Wsum' w l\n\n");

	
    fprintf( pFileW, "set output './pngFiles/phidotC.svg'\n");
    fprintf( pFileW, "set ylabel \"damage front speed phidot/c\"\n" );
    fprintf( pFileW, "plot for [i=10:100] './datFiles/energies.dat' usi 1:i title \"Segment \".(i-9) w l \n");

    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time        Wspr        Wdis        Wext");
    fprintf( pFile, "        Wkin   0.01*Wmax        Wsum     WdisLoc     WdisTLS    testWdis" );
    for (unsigned i = 1; i <= 100; ++i) fprintf( pFile, "   Segment %u", i); 
    fprintf( pFile, "\n");
    fclose( pFile );
}

void PotentialAvenger::plotForceDisp () {
    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotForceDisp.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Force vs. displacement\n" );
    fprintf( pFileW, "set xlabel \"displacement (mm)\"\n" );
    fprintf( pFileW, "set ylabel \"force (kN)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/forceDisp.svg'\n");
    fprintf( pFileW, "plot './datFiles/forceDisp.dat' usi 2:3 ti 'F' w l\n" );

    fprintf( pFileW, "set output './pngFiles/stressStrain.svg'\n");
    fprintf( pFileW, "set xlabel \"strain\"\n" );
    fprintf( pFileW, "set ylabel \"stress (GPa)\"\n" );
    fprintf( pFileW, "plot './datFiles/forceDisp.dat' usi 4:5 ti 'stress' w l\n" );
    
	fprintf( pFileW, "set output './pngFiles/stressDisp.svg'\n");
    fprintf( pFileW, "set xlabel \"displacement (mm)\"\n" );
    fprintf( pFileW, "set ylabel \"stress (GPa)\"\n" );
    fprintf( pFileW, "plot './datFiles/forceDisp.dat' usi 2:5 ti 'stress' w l\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FDFile = _path+"/datFiles/forceDisp.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FDFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time       u.end       force       e.end       s.end");
    fprintf( pFile, "\n");
    fclose( pFile );
}

void PotentialAvenger::plotFrags (){
    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Fragments\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:3 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Frags' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/numSegs.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:14 ti '# Segments' w l\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time      #frags   #altFrags   DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "      AltMin       StDev       Range        Skew    Ex. Kurt.      #Segs");
    fprintf( pFile, "((R*L^2)/|L|) (Locations)\n");
    fclose( pFile );
}

void PotentialAvenger::plotHisto () {
    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    if (_numFrag > 0) fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void PotentialAvenger::plotSTheta () {
	// Gnuplot file for fragmentation histogram
	FILE * pFileW;
	std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
	pFileW = fopen( sThetaFile.c_str(), "w" );
	fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
	fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
	fprintf( pFileW, " -- MH[DCML] (2010)\n");
	fprintf( pFileW, "datafile = './datFiles/stresstheta.dat'\n");
	fprintf( pFileW, "stats datafile;\n");
	fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCL.svg'\n");
	fprintf( pFileW, "plot for[i=1:1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:5 ti 'Link Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaSE.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 2:3 ti 'Spring Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Damage\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCLD.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:6 ti 'Damage' w l;\n\n" );
	fclose( pFileW );

    // Prepare Gnuplot data file
	_SThetaFile = _path+"/datFiles/stresstheta.dat";		//../results

    FILE * pFile;
    pFile = fopen( _SThetaFile.c_str(), "w" );
    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
    fclose( pFile );
}

void PotentialAvenger::plotResidual () {
	// residual information 
	FILE * pFileW;
	std::string residualFile = _path+"/gnuplot/plotResidual.plt";	//../results/
	pFileW = fopen( residualFile.c_str(), "w" );
	fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
	fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h> -- MH[DCML] (2010)\n" );
	fprintf( pFileW, "set title \"Residual vs. Time\"\n" );
	fprintf( pFileW, "set xlabel \"Time\"\n" );
	fprintf( pFileW, "set ylabel \"R0\"\n" );
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" ); 
	fprintf( pFileW, "set output './pngFiles/residual.svg'\n" );
	fprintf( pFileW, "plot './datFiles/residual.dat' using 1:2 ti '' with points;\n\n" );
	fprintf( pFileW, "set xlabel \"log10(R1/Yc)\"\n" );
	fprintf( pFileW, "set ylabel \"log10(R2/Yc,R3/Yc,R4/Yc)\"\n" );
	fprintf( pFileW, "set output './pngFiles/residualr1r2.svg'\n" );
	fprintf( pFileW, "plot './datFiles/residual.dat' using (log10(abs($2))):(log10(abs($2))) ti 'R1' with points, \\\n" );
	fprintf( pFileW, "     './datFiles/residual.dat' using (log10(abs($2))):(log10(abs($3))) ti 'R2' with points, \\\n" );
	fprintf( pFileW, "     './datFiles/residual.dat' using (log10(abs($2))):(log10(abs($4))) ti 'R3' with points, \\\n" );
	fprintf( pFileW, "     './datFiles/residual.dat' using (log10(abs($2))):(log10(abs($5))) ti 'R4' with points;\n\n" );
	fprintf( pFileW, "set output './pngFiles/residualIteration.svg'\n" );
	fprintf( pFileW, "set xlabel \"iteration number\"\n" );
	fprintf( pFileW, "set ylabel \"log10(R/Yc)\"\n" );
	fprintf( pFileW, "set nokey\n" );
	fprintf( pFileW, "set xtics (1,2,3,4)\n" );
	fprintf( pFileW, "set xrange [0.5:4.5]\n" );
	fprintf( pFileW, "plot for[i=2:5] './datFiles/residual.dat' using (i-1):(log10(abs(column(i)))) with points;\n" );
	fclose( pFileW );

    // Prepare Gnuplot data file
	_ResidualFile = _path+"/datFiles/residual.dat";		//../results

    FILE * pFile;
    pFile = fopen( _ResidualFile.c_str(), "w" );
    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Residual Information\n" );
    fprintf( pFile, "#Time       Residual\n" );
    fclose( pFile );
	
	//FILE * pFileW;
	std::string residualFile2 = _path+"/gnuplot/plotResidual2.plt";	//../results/
	pFileW = fopen( residualFile2.c_str(), "w" );
	fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
	fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h> -- MH[DCML] (2010)\n" );
	fprintf( pFileW, "set title \"Residual vs. Time\"\n" );
	fprintf( pFileW, "set xlabel \"Time\"\n" );
	fprintf( pFileW, "set ylabel \"R0\"\n" );
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" ); 
	fprintf( pFileW, "set output './pngFiles/residualMax.svg'\n" );
	fprintf( pFileW, "plot './datFiles/residual2.dat' using 1:2 ti '' with points;\n\n" );
	fprintf( pFileW, "set xlabel \"log10(R1/Yc)\"\n" );
	fprintf( pFileW, "set ylabel \"log10(R2/Yc,R3/Yc,R4/Yc)\"\n" );
	fprintf( pFileW, "set output './pngFiles/residualMaxr1r2.svg'\n" );
	fprintf( pFileW, "plot './datFiles/residual2.dat' using (log10(abs($2))):(log10(abs($2))) ti 'R1' with points, \\\n" );
	fprintf( pFileW, "     './datFiles/residual2.dat' using (log10(abs($2))):(log10(abs($3))) ti 'R2' with points, \\\n" );
	fprintf( pFileW, "     './datFiles/residual2.dat' using (log10(abs($2))):(log10(abs($4))) ti 'R3' with points, \\\n" );
	fprintf( pFileW, "     './datFiles/residual2.dat' using (log10(abs($2))):(log10(abs($5))) ti 'R4' with points;\n\n" );
	fprintf( pFileW, "set output './pngFiles/residualMaxIteration.svg'\n" );
	fprintf( pFileW, "set xlabel \"iteration number\"\n" );
	fprintf( pFileW, "set ylabel \"log10(R/Yc)\"\n" );
	fprintf( pFileW, "set nokey\n" );
	fprintf( pFileW, "set xtics (1,2,3,4)\n" );
	fprintf( pFileW, "set xrange [0.5:4.5]\n" );
	fprintf( pFileW, "plot for[i=2:5] './datFiles/residual2.dat' using (i-1):(log10(abs(column(i)))) with points;\n\n" );
	fprintf( pFileW, "set xlabel \"Time\"\n" );
	fprintf( pFileW, "set ylabel \"R0\"\n" );
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" ); 
	fprintf( pFileW, "set output './pngFiles/residualSum.svg'\n" );
unsigned zero = maxIteration+1;
cout << " zero = " << zero << endl;
	fprintf( pFileW, "plot './datFiles/residual2.dat' using %u:%u ti '' with points;\n\n", zero+1, zero+2 );
	fprintf( pFileW, "set xlabel \"log10(R1/Yc)\"\n" );
	fprintf( pFileW, "set ylabel \"log10(R2/Yc,R3/Yc,R4/Yc)\"\n" );
	fprintf( pFileW, "set output './pngFiles/residualSumr1r2.svg'\n" );
	fprintf( pFileW, "plot './datFiles/residual2.dat' using (log10(abs($%u))):(log10(abs($%u))) ti 'R1' with points, \\\n", zero+2, zero+2);
	fprintf( pFileW, "     './datFiles/residual2.dat' using (log10(abs($%u))):(log10(abs($%u))) ti 'R2' with points, \\\n", zero+2, zero+3);
	fprintf( pFileW, "     './datFiles/residual2.dat' using (log10(abs($%u))):(log10(abs($%u))) ti 'R3' with points, \\\n", zero+2, zero+4);
	fprintf( pFileW, "     './datFiles/residual2.dat' using (log10(abs($%u))):(log10(abs($%u))) ti 'R4' with points;\n\n", zero+2, zero+5);
	fprintf( pFileW, "set output './pngFiles/residualSumIteration.svg'\n" );
	fprintf( pFileW, "set xlabel \"iteration number\"\n" );
	fprintf( pFileW, "set ylabel \"log10(R/Yc)\"\n" );
	fprintf( pFileW, "set nokey\n" );
	fprintf( pFileW, "set xtics (1,2,3,4)\n" );
	fprintf( pFileW, "set xrange [0.5:4.5]\n" );
	fprintf( pFileW, "plot for[i=%u:%u] './datFiles/residual2.dat' using (i-1):(log10(abs(column(i)))) with points;\n", zero+2, zero+5);
	fclose( pFileW );

    // Prepare Gnuplot data file
	_ResidualFile2 = _path+"/datFiles/residual2.dat";		//../results

    //FILE * pFile;
    pFile = fopen( _ResidualFile2.c_str(), "w" );
    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Residual Information\n" );
    fprintf( pFile, "#Time       MaxResidual  SumResidual\n" );
    fclose( pFile );
}

/*------------------------------ P R I V A T E -------------------------------*/


void PotentialAvenger::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_";//+ convertInt(_myid) + "_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += convertInt(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    unsigned Ncell = printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile, Ncell );
}

void PotentialAvenger::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

unsigned PotentialAvenger::printMesh ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf ( pFile, "POINTS %d float\n", Nnod);
    for ( unsigned i = 0; i < Nnod; i++ ) {
        double xx = x[i];			//NodPos
        double y = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", xx, y, 0.0 );
    }

    unsigned Ncell = 0;
    if (visualizeCracks) {
        for ( unsigned i = 0; i < Nelt; i++ ) {
	    	if (dE[i] < 1) Ncell++;
    	} 
    } else {
        Ncell = Nelt;
    }

    fprintf ( pFile, "\nCELLS %d %d\n", Ncell, 3*Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (dE[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d %12d %12d\n", 2, i, i+1 );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (dE[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );

    return Ncell;
}

void PotentialAvenger::printPointData ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    //int pointData = _NodPos.size();

    fprintf ( pFile, "POINT_DATA %d", Nnod);
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    for ( unsigned i = 0; i < u.size(); i++ ) {
        double dx = printable(u[i]);	//Dis[i][0][0]
        double dy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }
    fprintf ( pFile, "\nVECTORS velocities float\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) {
        double vx = printable(v[i]);
        double vy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    fprintf ( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS phi float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %12.3e \n", printable(phi[i]/lc));
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS inTLSnode int\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %u \n", inTLSnode[i]);
    fprintf ( pFile, "\n" );
    
	fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) if (dE[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(s[i]));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Ybar/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) if (dE[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(Ybar[i]/Ycbar[i]));
    fprintf( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS damage float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) if (dE[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", printable(d[i]));
    fprintf ( pFile, "\n" );

	
    fprintf ( pFile, "\nSCALARS damageRate float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) if (dE[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", printable((dE[i] - dE_1[i]) / dt));
    fprintf ( pFile, "\n" );

    fclose( pFile );
}

void PotentialAvenger::printCellData ( const std::string& vtkFile, const unsigned& Ncell ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", Ncell );
    
	fprintf( pFile, "\nSCALARS Yraw/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
assert(simpleY.size() == Nelt); assert(Ycv.size() == Nnod);
    for ( unsigned i = 0; i < Nelt; i++ ) if (dE[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(simpleY[i]/(0.5*(Ycv[i]+Ycv[i+1]) )));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS strain float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (dE[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e\n", printable(e[i]));
    fprintf( pFile, "\n" );
	
	fprintf( pFile, "\nSCALARS stressElem float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (dE[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(sE[i]));
    fprintf( pFile, "\n" );

    
	fprintf ( pFile, "\nSCALARS absGradPhi float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhi[i])));
    fprintf ( pFile, "\n" );
    

    fclose( pFile );
}

void PotentialAvenger::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12.3e", strain_energy );
        fprintf( pFile, "%12.3e", dissip_energy );
        fprintf( pFile, "%12.3e", ext_energy );
        fprintf( pFile, "%12.3e", kinetic_energy );
		fprintf( pFile, "%12.3e", max_energy * 0.01 );
		fprintf( pFile, "%12.3e", tot_energy );
		fprintf( pFile, "%12.3e", dissip_energy_local );
		fprintf( pFile, "%12.3e", dissip_energy_TLS );
		fprintf( pFile, "%12.3e", test_dissip_energy );
//		for (unsigned i = 0; i < phidot.size(); ++i) fprintf( pFile, "%12.3e", phidot.at(i)/sqrt(E/rho)  );
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printForceDisp () const {
	
	if (_numFrag > 5) return;

    if ( _FDFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FDFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12.3e", u.back() );
        fprintf( pFile, "%12.3e", Fboundary );
        fprintf( pFile, "%12.3e", e.back() );
        fprintf( pFile, "%12.3e", s.back() );
        fprintf( pFile, "\n" );
		fclose( pFile );
    }
}

void PotentialAvenger::printFrags (const vector<double>& fragLength, const unsigned nSegs) {
    double DSum = 0.0;
    for (unsigned i = 0; i < d.size(); ++i) DSum += d[i];

    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12u", _numFrag );
		//fprintf( pFile, "%12u", static_cast<unsigned>(altFragLength.size()) );
		fprintf( pFile, "%12u", 0); 
        fprintf( pFile, "%12.3f", DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fAltMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	fprintf( pFile, "%12.3f", _fSkew );
	fprintf( pFile, "%12.3f", _fExKurtosis );
	fprintf( pFile, "%12u", nSegs );
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < fragLength.size(); i++){
		fprintf( pFile, "%12f", fragLength[i] );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printSTheta () {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < Nelt; i++) {
	    double sprTheta = (double)(360*(i+0.5))/(double)(Nelt);
	    double cohTheta = (double)(360*(i+1))/(double)(Nelt);
	    fprintf( pFile, "%12.3e", t[_Nt] );
	    fprintf( pFile, "%12.3f", sprTheta );
        fprintf( pFile, "%12.3e", s[i] );
        fprintf( pFile, "%12.3f", cohTheta );
//        fprintf( pFile, "%12.3e", _sigCoh[i] );
        fprintf( pFile, "%12.3e", d[i] );
        fprintf( pFile, "%12.3f", (double)(i) );
        fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}
void PotentialAvenger::printResidual () {
    if ( _ResidualFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _ResidualFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	    fprintf( pFile, "%12.3e", t[_Nt] );
		for (unsigned i = 0; i < maxIteration; ++i) fprintf( pFile, "%12.3e", residualVec[i] );
    	fprintf( pFile, "\n" );
		fclose( pFile );
    }
    if ( _ResidualFile2.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _ResidualFile2.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	    fprintf( pFile, "%12.3e", t[_Nt] );
		for (unsigned i = 0; i < maxIteration; ++i) fprintf( pFile, "%12.3e", residualMax[i] );
		for (unsigned i = 0; i < maxIteration; ++i) fprintf( pFile, "%12.3e", residualSum[i] );
    	fprintf( pFile, "\n" );
		fclose( pFile );
    }
}


void PotentialAvenger::fragmentStats(const vector<double>& fragLength) {

    if (fragLength.size() == 0) return;

	//Initialize statistics of fragment length distribution
	_fMean = 0;
	_fMed = 0;
	_fMax = 0;
	_fMin = 0;
	_fAltMin = 0;
	_fStDev = 0;
	_fRange = 0;
	_fSkew = 0;
	_fExKurtosis = 0;

	//If there are any fragments...
	//Calculate Median
	// Sort the list in ascending order
	vector<double> fragLengthSort = fragLength;
    sort(fragLengthSort.begin(), fragLengthSort.end());
//	vector<double> altFragLengthSort = altFragLength;
//    sort(altFragLengthSort.begin(), altFragLengthSort.end());

	if (fragLength.size() % 2 == 0) {
        	//If even number, take average of two middle values
		_fMed = ( fragLengthSort[ (unsigned)(fragLengthSort.size() * 0.5) ]
			+ fragLengthSort[ (unsigned)(fragLengthSort.size() * 0.5) -1 ] ) * 0.5;
	} else {
		//If odd number, take middle value
		_fMed = fragLengthSort[ (fragLengthSort.size() - 1) / 2 ];
	}
	//Calculate Max, Min, Range
	_fMax = fragLengthSort.back();
	_fMin = fragLengthSort.front();
//n	_fAltMin = altFragLengthSort.front();
	_fRange = _fMax - _fMin;

	//Calculate Mean
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of lengths
		_fMean += fragLength[k];
	}
    //Mean = sum / number
	_fMean = _fMean / _numFrag;

	//Calculate Std. Deviation
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fStDev += pow( (fragLengthSort[k] - _fMean), 2);
	}
	_fStDev = sqrt( _fStDev / _numFrag ) ;

	//Calculate Skew
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fSkew += pow( (fragLengthSort[k] - _fMean), 3);
	}
	_fSkew = _fSkew / (_numFrag * pow(_fStDev,3) );

	//Calculate Kurtosis
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fExKurtosis += pow( (fragLengthSort[k] - _fMean), 4);
	}
	_fExKurtosis = _fExKurtosis / (_numFrag * pow(_fStDev,4) ) - 3.0;
    return;
}


void PotentialAvenger::printHisto(const std::vector<double>& fragLength) {
    // Prints Histogram and scaled 1-cdf figure
    vector<vector<double> > fragInvCDF;
    vector<unsigned> fHisto;
    vector<double> fragLengthSort = fragLength;

    if (_numFrag > 1) {

        sort(fragLengthSort.begin(), fragLengthSort.end());

		fragInvCDF.resize(2);
		fragInvCDF[0].resize(1000);	//a length, from zero to the max. fragment size
		fragInvCDF[1].resize(1000);	//number of fragments larger than this length
		fHisto.assign(25, 0);		//number of bins for the fragment histogram
	
		//Histogram - 25 bins
		 double max = _fMax;	//size
		//Step through fragment length list; increase count in the bin if fragment fits
		for (unsigned k = 0; k < fragLengthSort.size(); k++){
            double length = fragLengthSort[k];
			if (length < max * 0.04) fHisto[0]++;
			if ((length < max * 0.08) && (length >= max * 0.04)) fHisto[1]++;
			if ((length < max * 0.12) && (length >= max * 0.08)) fHisto[2]++;
			if ((length < max * 0.16) && (length >= max * 0.12)) fHisto[3]++;
			if ((length < max * 0.20) && (length >= max * 0.16)) fHisto[4]++;
			if ((length < max * 0.24) && (length >= max * 0.20)) fHisto[5]++;
			if ((length < max * 0.28) && (length >= max * 0.24)) fHisto[6]++;
			if ((length < max * 0.32) && (length >= max * 0.28)) fHisto[7]++;
			if ((length < max * 0.36) && (length >= max * 0.32)) fHisto[8]++;
			if ((length < max * 0.40) && (length >= max * 0.36)) fHisto[9]++;
			if ((length < max * 0.44) && (length >= max * 0.40)) fHisto[10]++;
			if ((length < max * 0.48) && (length >= max * 0.44)) fHisto[11]++;
			if ((length < max * 0.52) && (length >= max * 0.48)) fHisto[12]++;
			if ((length < max * 0.56) && (length >= max * 0.52)) fHisto[13]++;
			if ((length < max * 0.60) && (length >= max * 0.56)) fHisto[14]++;
			if ((length < max * 0.64) && (length >= max * 0.60)) fHisto[15]++;
			if ((length < max * 0.68) && (length >= max * 0.64)) fHisto[16]++;
			if ((length < max * 0.72) && (length >= max * 0.68)) fHisto[17]++;
			if ((length < max * 0.76) && (length >= max * 0.72)) fHisto[18]++;
			if ((length < max * 0.80) && (length >= max * 0.76)) fHisto[19]++;
			if ((length < max * 0.84) && (length >= max * 0.80)) fHisto[20]++;
			if ((length < max * 0.88) && (length >= max * 0.84)) fHisto[21]++;
			if ((length < max * 0.92) && (length >= max * 0.88)) fHisto[22]++;
			if ((length < max * 0.96) && (length >= max * 0.92)) fHisto[23]++;
			if ((length <= max) && (length >= max * 0.96)) fHisto[24]++;
		}

		//Open file to record histogram and 1-cdf data
		if ( _HistoFile.size() > 0 ) {
			FILE * pFile;
			pFile = fopen( _HistoFile.c_str(), "a" );
			double j = 0;
			for (unsigned i = 0; i < 1000; i++) {

				//grab the 1-cdf data; 
				unsigned count = 0;
				j = max * (static_cast<double>(i) / 1000.0);	//from 0 to max length, 1000 increments
				for (unsigned k = 0; k < fragLengthSort.size(); k++) {
                    double length = fragLengthSort[k];
					if (length > j) {		//if frag length greater than j, add to count
						count += 1;
					}
				}
		
				//save to vector
				fragInvCDF[0][i] = j;
				fragInvCDF[1][i] = (double)count;
				fprintf( pFile, "%6.3e %u", j, count);		//print to file

				//print histogram info to file - relative size (% of max frag length) & count
				if (i < 25) {	//piggybacking the for loop, only need the first 25
					fprintf( pFile, " %f %u", (double)(i*4+2), fHisto[i] );
				} else {
					fprintf( pFile, " 0 0");
				}
				fprintf( pFile, "\n" );
			}

			//print raw fragment sizes to file
			fprintf( pFile, "# Sizes: \n" );
			for (unsigned k = 0; k < fragLength.size(); k++){
                double length = fragLength[k];
				fprintf( pFile, "%12.3e \n", length );
			}

			fclose( pFile );
		}
    }
    return;
}


void PotentialAvenger::printClean () const {
    std::string cleanPath = _path+"/clean.sh";
cout << " path = " << _path << endl;
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "cd ./automatedRuns/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png/svg files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.svg; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; find . -name \"*.vtk\" -print0 | xargs -0 rm -f; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    //int status = system( shellCmd.c_str() );
	system( shellCmd.c_str() );

    shellCmd = "./" + cleanPath;
	system( shellCmd.c_str() );

}

